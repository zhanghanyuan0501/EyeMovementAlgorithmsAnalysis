Podsumowując, w tej pracy zrealizowano cel określony w rozdziale \ref{chapter:ch1}, tzn. zaimplementowano wybrane algorytmy wykrywania fiksacji oraz przeprowadzono ich analizę. Zanim rozpoczęto analizę należało się zaznajomić z terminologią stosowaną przy tego typu rozwiązaniach, jak również rozważyć sposób przygotowania aplikacji. Zanim przystąpiono do implementacji wybrano platformę do implementacji, oraz zastanowiono się nad tym, które algorytmy wybrać do dalszej analizy. Ze względu na podzielenie aplikacji na wiele plików, m.in. podzielenie każdego algorytmu i potrzebnych mu metod na osobne pliki, czytelność kodu i możliwość rozwoju aplikacji w trakcie jej tworzenia stała się prostsza.\par
Celem dalszego rozwoju tego projektu, można zaimplementować obsługę wielu wątków, na pewno doprowadziłoby to do redukcji czasu wykonywania obliczeń. Wykorzystanoby to w podzieleniu konkretnych modułów aplikacji na odpowiednie wątki, czy też uruchamianie obliczeń plików na osobnych wątkach. Kolejnym krokiem rozwoju mogłaby być implementacja algorytmów powierzchnowych, czy też innych algorytmów dyspersyjnych lub prędkościowych opisanych w pracy \cite{Main}. Możnaby się zastanowić także nad implementacją tych algorytmów przy wykorzystaniu innej platformy, np. \emph{R}, w celu porównania wydajności różnych narzędzi. Ostatnim elementem, dla którego na ten moment zauważa się możliwość rozwoju jest wykorzystanie różnych klasyfikatorów przy uczeniu maszynowym oraz ich porównanie, gdyż rozwiązanie zaprezentowane w rozdziale \ref{ssec:machinelearningalg} pozwala na implementację wielu klasyfikatorów, a nie tylko regresji logistycznej, jednak przez ograniczenia czasowe zaniechano tego w tej wersji projektu.\par
Ze względu na małe doświadczenie w korzystaniu z niektórych narzędzi i rozwiązań przed rozpoczęciem tworzenia projektu, np. uczenia maszynowego, obsługi biblioteki \emph{NumPy} czy też tylko podstawowa znajomość języka \emph{Python}, niektóre elementy potrzebne do poprawnego zaimplementowania funkcjonalności początkowo sprawiały proste problemy typu obsługa specjalnych tablic, tworzenie specjalnych typów obiektów. Przejrzystość w dostępnej dokumentacji do tych modułów, czy też pospolitość występowania tego rodzaju problemów na forach dyskusyjnych dotyczących konkretnych rozwiązań ułatwiły naukę, a przez to rozwiązywanie postawionych problemów.\par
Realizacja tych problemów pozwoliła na poszerzenie wiedzy w zakresie uczenia maszynowego, czy też dokładnej analizy danych, oraz uporządkowała podstawy biologii związanej z budową i działaniem oka. Również zaobserwowany został rozwój w jakości tworzonego kodu, zgodnie z zasadami jego tworzenia w języku Python.